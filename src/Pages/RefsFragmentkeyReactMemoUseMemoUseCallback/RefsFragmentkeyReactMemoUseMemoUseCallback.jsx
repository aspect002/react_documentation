import React from "react";
import Typography from "../../Components/Typography/Typography";
import ButtonUp from 'Utils/ButtonUp/ButtonUp';
const RefsFragmentkeyReactMemoUseMemo = () => {
  const exampleText = `Refs (далее просто «ссылки») предоставляет способ доступа к DOM-узлам или React-элементам, созданным в методе render().

    Есть несколько хороших примеров использования ссылок:

    *Управление фокусом, выделение текста или воспроизведение медиаресурсами.
    *Выполнение анимаций в императивном подходе.
    *Интеграция со сторонними библиотеками, взаимодействующие с DOM.
    *Ссылки создаются с использованием React.createRef() и добавляются к React-элементам с помощью атрибута ref. Ссылки обычно присваиваются свойству экземпляра, когда компонент создаётся таким образом, чтобы на них можно было ссылаться по всему компоненту.

    \`\`\`
                class MyComponent extends React.Component {
                    constructor(props) {
                      super(props);
                      this.myRef = React.createRef();
                    }
                    render() {
                      return <div ref={this.myRef} />;
                    }
                }
                \`\`\`
    В функциональных компонентах используется хук useRef:

    \`\`\`
                import { useRef } from 'react';

                function MyComponent () {
                    const refContainer = useRef(initialValue);
                    return (
                        <div ref={refContainer} />
                    );
                }
                \`\`\`
    useRef возвращает изменяемый ref-объект, свойство .current которого инициализируется переданным аргументом (initialValue). Возвращённый объект будет сохраняться в течение всего времени жизни компонента.


    ~~~С помощью фрагментов можно сгруппировать список дочерних элементов без добавления дополнительных узлов в DOM.

~Используем React.Fragment или выполняем импорт, чтобы использовать Fragment:
\`\`\`
import { Fragment } from 'react';
\`\`\`
~Заменяем теги div на Fragment:

\`\`\`
            class ChildComponent extends React.Component {
                render() {
                    return (
                        <Fragment>
                            <h1>Hello Child Component</h1>
                        </Fragment>
                    )
                }
            }
\`\`\`
Существует сокращенная запись (импортировать не нужно):

\`\`\`
             class ChildComponent extends React.Component {
                render() {
                    return (
                        <>
                            <h1>Hello Child Component</h1>
                        </>
                    )
                }
            }
            \`\`\`
Недостаток сокращенной записи: нельзя использовать атрибут key.


Ключи помогают React определять, какие элементы были изменены, добавлены или удалены. Их необходимо указывать, чтобы React мог сопоставлять элементы массива с течением времени:

\`\`\`
            const numbers = [1, 2, 3, 4, 5];
            const listItems = numbers.map((number) =>
              <li key={number.toString()}>
                {number}
              </li>
            );
            \`\`\`
Лучший способ выбрать ключ — это использовать строку, которая будет явно отличать элемент списка от его соседей. Чаще всего вы будете использовать ID из ваших данных как ключи:

\`\`\`
            const todoItems = todos.map((todo) =>
            <li key={todo.id}>
              {todo.text}
            </li>
            );
            \`\`\`
~~~Ключи нужно определять непосредственно внутри массивов.

~Если не указать ключи, в консоли увидим сообщение: Warning: Each child in an array or iterator should have a unique “key” prop.

~Ключи оптимизируют работу с элементами массивов, уменьшают количество ненужных удалений и созданий элементов.

~Без key механизм reconciliation сверяет компоненты попарно между текущим и новым VDOM. Из-за этого может происходить большое количество лишних перерисовок интерфейса, что замедляет работу приложения.

~Добавляя key, вы помогаете механизму reconciliation тем, что с key он сверяет не попарно, а ищет компоненты с тем же key (тег / имя компонента при этом учитывается) — это уменьшает количество перерисовок интерфейса. Обновлены/добавлены будут только те элементы, которые были изменены/не встречались в предыдущем дереве.

~Следите, чтобы не появлялись дублирующие key, при переключении отображения у новых данных не совпадали ключи. Это может привести к нежелательным сайд-эффектам, таким как анимации, или некорректной логике поведения элемента.

~key и ref — специальные props. Они недоступны в компоненте, их нет в child.props. Можно получить доступ в родителе через child.key, но реальных областей применения для этого практически нет. Если в дочерних компонентах нужен key — правильным решением будет задублировать в prop id, например.




~~~React.memo
\`\`\`
            const MyComponent = React.memo(function MyComponent(props) {
                /* рендер с использованием пропсов */
            });
            \`\`\`
React.memo — это компонент высшего порядка.

Компонент высшего порядка — это функция, которая принимает компонент и возвращает новый компонент.

Если ваш компонент всегда рендерит одно и то же при неменяющихся пропсах, вы можете обернуть его в вызов React.memo для повышения производительности в некоторых случаях, мемоизируя тем самым результат. Это значит, что React будет использовать результат последнего рендера, избегая повторного рендеринга.

~React.memo затрагивает только изменения пропсов. Если функциональный компонент обёрнут в React.memo и использует useState, useReducer или useContext, он будет повторно рендериться при изменении состояния или контекста.

По умолчанию он поверхностно сравнивает вложенные объекты в объекте props. Если вы хотите контролировать сравнение, вы можете передать свою функцию сравнения в качестве второго аргумента.

\`\`\`
            function MyComponent(props) {
                /* рендер с использованием пропсов */
              }
              function areEqual(prevProps, nextProps) {
                /*
                возвращает true, если nextProps рендерит
                тот же результат что и prevProps,
                иначе возвращает false
                */
            }
            export default React.memo(MyComponent, areEqual);
            \`\`\`
Этот метод предназначен только для оптимизации производительности.

Аналогом в классовых компонентах выступает метод shouldComponentUpdate()

\`\`\`
            shouldComponentUpdate(nextProps, nextState) {
                return !shallowEqual (nextProps, this.props) ||
                       !shallowEqual (nextState, this.state);
            }
            \`\`\`




            ~~~useMemo
            React хук useMemo предназначен для мемоизации вычислений в функциональных компонентах. Он позволяет сохранять результат вычислений и повторно использовать его, если входные значения (зависимости) не изменились. Это может существенно повысить производительность, особенно в случаях, когда сложные вычисления выполняются при каждом рендеринге компонента.

             ~Примеры использования

            1. Вычисление производительной функции:

            \`\`\`
            import React, { useMemo } from 'react';

            const MyComponent = ({ data }) => {
              const processedData = useMemo(() => {
                // Вычисления, требующие много времени или ресурсов
                // Например, фильтрация или сортировка массива данных
                return processData(data);
              }, [data]); // Зависимость - значение пропса "data"

              return (
                <div>
                  {processedData}
                </div>
              );
            };
            \`\`\`

            ~В этом примере результат вычисления processData будет сохраняться и пересчитываться только при изменении значения пропса data. При последующих рендерах, если data не изменилось, будет использован сохраненный результат.

            1. Кэширование компонента:

            \`\`\`
            import React, { useMemo } from 'react';

            const ExpensiveComponent = ({ propA, propB }) => {
              // Сложный компонент, требующий много ресурсов
              return (
                // ...
              );
            };

            const MyComponent = ({ data }) => {
              const cachedComponent = useMemo(() => {
                // Компонент будет кэширован при каждом изменении propA или propB
                return <ExpensiveComponent propA={propA} propB={propB} />;
              }, [propA, propB]);

              return (
                <div>
                  {cachedComponent}
                </div>
              );
            };
            \`\`\`


            В этом примере компонент ExpensiveComponent будет пересоздаваться только при изменении пропсов propA или propB. При остальных рендерах будет использоваться кэшированный компонент, что помогает снизить нагрузку на рендеринг сложных компонентов.


~~~useCallback

Хук useCallback принимает два параметра:

1. Callback-функция: Это функция, которую мы хотим мемоизировать. Когда этот сallback вызывается, useCallback возвращает эту же функцию, если зависимости не изменились.
2. Массив зависимостей: Это массив значений, от которых зависит сallback-функция. Если хотя бы одно из значений в массиве изменится, хук useCallback вернет новую мемоизированную версию колбэка. Если массив пустой, то колбэк будет создан только один раз, при первом рендере компонента.

Вот пример использования useCallback с обоими параметрами:

\`\`\`
const memoizedCallback = useCallback(
  () => doSomething(a, b),
  [a, b],
);
\`\`\`

В этом примере useCallback создает мемоизированную версию функции doSomething, и эта версия будет обновляться только в случае изменения значений a или b. Если a и b не изменятся между рендерами компонента, то useCallback вернет ту же самую мемоизированную функцию.


















`;
  return (
    <div>
      <div id="top" style={{ position: 'relative', top: 0 }}></div>

      <Typography title="Refs, Fragment, key, React.memo, useMemo">
        {exampleText}
      </Typography>
      <ButtonUp />
    </div>
  );
};

export default RefsFragmentkeyReactMemoUseMemo;
